// Code generated by schema-generate. DO NOT EDIT.

package coriolis

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// Blueprint
type Blueprint struct {
}

// CargoHatch
type CargoHatch struct {
	Enabled  bool `json:"enabled"`
	Priority int  `json:"priority"`
}

// Components The components used by this build
type Components struct {
	Hardpoints []interface{} `json:"hardpoints"`
	Internal   []interface{} `json:"internal"`

	// The set of standard components across all ships
	Standard *Standard     `json:"standard"`
	Utility  []interface{} `json:"utility"`
}

// FrameShiftDrive
type FrameShiftDrive struct {
	Blueprint     *Blueprint     `json:"blueprint,omitempty"`
	Class         int            `json:"class"`
	Enabled       bool           `json:"enabled"`
	Modifications *Modifications `json:"modifications,omitempty"`
	Priority      int            `json:"priority"`
	Rating        interface{}    `json:"rating"`
}

// FuelTank
type FuelTank struct {
	Blueprint     *Blueprint     `json:"blueprint,omitempty"`
	Class         int            `json:"class"`
	Enabled       bool           `json:"enabled"`
	Modifications *Modifications `json:"modifications,omitempty"`
	Priority      int            `json:"priority"`
	Rating        interface{}    `json:"rating"`
}

// HardpointsItems_object
type HardpointsItems_object struct {
	Blueprint *Blueprint `json:"blueprint,omitempty"`
	Class     int        `json:"class"`
	Enabled   bool       `json:"enabled"`

	// The group of the component, e.g. 'Beam Laser', or 'Missile Rack'
	Group         string         `json:"group"`
	Modifications *Modifications `json:"modifications,omitempty"`
	Mount         string         `json:"mount"`

	// The name identifing the component (if applicable), e.g. 'Retributor', or 'Mining Lance'
	Name     string      `json:"name,omitempty"`
	Priority int         `json:"priority"`
	Rating   interface{} `json:"rating"`
}

// InternalItems_object
type InternalItems_object struct {
	Blueprint *Blueprint `json:"blueprint,omitempty"`
	Class     int        `json:"class"`
	Enabled   bool       `json:"enabled"`

	// The group of the component, e.g. 'Shield Generator', or 'Cargo Rack'
	Group         string         `json:"group"`
	Modifications *Modifications `json:"modifications,omitempty"`

	// The name identifying the component (if applicable), e.g. 'Advance Discovery Scanner', or 'Detailed Surface Scanner'
	Name     string      `json:"name,omitempty"`
	Priority int         `json:"priority"`
	Rating   interface{} `json:"rating"`
}

// LifeSupport
type LifeSupport struct {
	Blueprint     *Blueprint     `json:"blueprint,omitempty"`
	Class         int            `json:"class"`
	Enabled       bool           `json:"enabled"`
	Modifications *Modifications `json:"modifications,omitempty"`
	Priority      int            `json:"priority"`
	Rating        interface{}    `json:"rating"`
}

// Modifications
type Modifications struct {
}

// PowerDistributor
type PowerDistributor struct {
	Blueprint     *Blueprint     `json:"blueprint,omitempty"`
	Class         int            `json:"class"`
	Enabled       bool           `json:"enabled"`
	Modifications *Modifications `json:"modifications,omitempty"`
	Priority      int            `json:"priority"`
	Rating        interface{}    `json:"rating"`
	Name          string         `json:"name,omitempty"`
}

// PowerPlant
type PowerPlant struct {
	Blueprint     *Blueprint     `json:"blueprint,omitempty"`
	Class         int            `json:"class"`
	Enabled       bool           `json:"enabled"`
	Modifications *Modifications `json:"modifications,omitempty"`
	Priority      int            `json:"priority"`
	Rating        interface{}    `json:"rating"`
	Name          string         `json:"name,omitempty"`
}

// ReferencesItems
type ReferencesItems struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`

	// The name of the 3rd party, .e.g 'Coriolis.io' or 'E:D Shipyard'
	Name string `json:"name"`

	// The link/url to the 3rd party referencing this build/loadout
	Url string `json:"url"`
}

// Sensors
type Sensors struct {
	Blueprint     *Blueprint     `json:"blueprint,omitempty"`
	Class         int            `json:"class"`
	Enabled       bool           `json:"enabled"`
	Modifications *Modifications `json:"modifications,omitempty"`
	Priority      int            `json:"priority"`
	Rating        interface{}    `json:"rating"`
}

// ShipLoadout The details for a specific ship build/loadout
type ShipLoadout struct {

	// The components used by this build
	Components *Components `json:"components"`

	// The ship manufacturer
	Manufacturer string `json:"manufacturer,omitempty"`

	// The name of the build/loadout
	Name string `json:"name"`

	// 3rd Party references and/or links to this build/loadout
	References []*ReferencesItems `json:"references,omitempty"`

	// The full display name of the ship
	Ship string `json:"ship"`

	// Optional statistics from the build
	Stats *Stats `json:"stats,omitempty"`
}

// Standard The set of standard components across all ships
type Standard struct {
	Bulkheads        interface{}       `json:"bulkheads"`
	CargoHatch       *CargoHatch       `json:"cargoHatch"`
	FrameShiftDrive  *FrameShiftDrive  `json:"frameShiftDrive"`
	FuelTank         *FuelTank         `json:"fuelTank"`
	LifeSupport      *LifeSupport      `json:"lifeSupport"`
	PowerDistributor *PowerDistributor `json:"powerDistributor"`
	PowerPlant       *PowerPlant       `json:"powerPlant"`
	Sensors          *Sensors          `json:"sensors"`
	Thrusters        *Thrusters        `json:"thrusters"`
}

// Stats Optional statistics from the build
type Stats struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Agility              int                    `json:"agility,omitempty"`

	// Sum of base armour + any hull reinforcements
	Armour float64 `json:"armour,omitempty"`

	// Armour added through Hull reinforcement
	ArmourAdded        float64 `json:"armourAdded,omitempty"`
	BaseArmour         int     `json:"baseArmour,omitempty"`
	BaseShieldStrength float64 `json:"baseShieldStrength,omitempty"`

	// Maximum boost speed of the ships (4 pips, straight-line)
	Boost         float64 `json:"boost,omitempty"`
	CargoCapacity int     `json:"cargoCapacity,omitempty"`

	// Ship Class/Size [Small, Medium, Large]
	Class        interface{} `json:"class,omitempty"`
	FuelCapacity int         `json:"fuelCapacity,omitempty"`

	// Single Jump range with a full tank (unladenMass + fuel)
	FullTankRange float64 `json:"fullTankRange,omitempty"`

	// Cost of the ship's hull
	HullCost int `json:"hullCost,omitempty"`

	// Multiplier for explosive damage to hull
	HullExplRes float64 `json:"hullExplRes,omitempty"`

	// Multiplier for kinetic damage to hull
	HullKinRes float64 `json:"hullKinRes,omitempty"`

	// Mass of the Ship hull only
	HullMass float64 `json:"hullMass,omitempty"`

	// Multiplier for thermal damage to hull
	HullThermRes float64 `json:"hullThermRes,omitempty"`

	// Mass of the Ship + fuel + cargo (hull + all components + fuel tank + cargo capacity)
	LadenMass float64 `json:"ladenMass,omitempty"`

	// Single Jump range with full cargo load, see ladenMass
	LadenRange float64 `json:"ladenRange,omitempty"`

	// Mass Lock Factor of the Ship
	Masslock int `json:"masslock,omitempty"`

	// Shield strength in Mega Joules (Mj)
	Shield float64 `json:"shield,omitempty"`

	// Multiplier for explosive damage to shields
	ShieldExplRes float64 `json:"shieldExplRes,omitempty"`

	// Multiplier for kinetic damage to shields
	ShieldKinRes float64 `json:"shieldKinRes,omitempty"`

	// Multiplier for thermal damage to shields
	ShieldThermRes float64 `json:"shieldThermRes,omitempty"`

	// Maximum speed of the ships (4 pips, straight-line)
	Speed float64 `json:"speed,omitempty"`

	// Total cost of the loadout, including discounts
	TotalCost float64 `json:"totalCost,omitempty"`

	// Total damage dealt per second of all weapons
	TotalDps float64 `json:"totalDps,omitempty"`

	// Total energy consumed per second of all weapons
	TotalEps float64 `json:"totalEps,omitempty"`

	// Total heat generated per second of all weapons
	TotalHps float64 `json:"totalHps,omitempty"`

	// Mass of the Ship (hull + all components)
	UnladenMass float64 `json:"unladenMass,omitempty"`

	// Single Jump range when unladen, see unladenMass
	UnladenRange float64 `json:"unladenRange,omitempty"`
}

// Thrusters
type Thrusters struct {
	Blueprint     *Blueprint     `json:"blueprint,omitempty"`
	Class         int            `json:"class"`
	Enabled       bool           `json:"enabled"`
	Modifications *Modifications `json:"modifications,omitempty"`

	// The name identifing the thrusters (if applicable), e.g. 'Enhanced Performance'
	Name     string      `json:"name,omitempty"`
	Priority int         `json:"priority"`
	Rating   interface{} `json:"rating"`
}

// UtilityItems_object
type UtilityItems_object struct {
	Blueprint *Blueprint `json:"blueprint,omitempty"`
	Class     int        `json:"class"`
	Enabled   bool       `json:"enabled"`

	// The group of the component, e.g. 'Shield Booster', or 'Kill Warrant Scanner'
	Group         string         `json:"group"`
	Modifications *Modifications `json:"modifications,omitempty"`

	// The name identifing the component (if applicable), e.g. 'Point Defence', or 'Electronic Countermeasure'
	Name     string      `json:"name,omitempty"`
	Priority int         `json:"priority"`
	Rating   interface{} `json:"rating"`
}

func (strct *CargoHatch) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Enabled" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "enabled" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Priority" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "priority" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CargoHatch) UnmarshalJSON(b []byte) error {
	enabledReceived := false
	priorityReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "enabled":
			if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
				return err
			}
			enabledReceived = true
		case "priority":
			if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
				return err
			}
			priorityReceived = true
		}
	}
	// check if enabled (a required property) was received
	if !enabledReceived {
		return errors.New("\"enabled\" is required but was not present")
	}
	// check if priority (a required property) was received
	if !priorityReceived {
		return errors.New("\"priority\" is required but was not present")
	}
	return nil
}

func (strct *Components) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Hardpoints" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "hardpoints" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"hardpoints\": ")
	if tmp, err := json.Marshal(strct.Hardpoints); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Internal" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "internal" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"internal\": ")
	if tmp, err := json.Marshal(strct.Internal); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Standard" field is required
	if strct.Standard == nil {
		return nil, errors.New("standard is a required field")
	}
	// Marshal the "standard" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"standard\": ")
	if tmp, err := json.Marshal(strct.Standard); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Utility" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "utility" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"utility\": ")
	if tmp, err := json.Marshal(strct.Utility); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Components) UnmarshalJSON(b []byte) error {
	hardpointsReceived := false
	internalReceived := false
	standardReceived := false
	utilityReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "hardpoints":
			if err := json.Unmarshal([]byte(v), &strct.Hardpoints); err != nil {
				return err
			}
			hardpointsReceived = true
		case "internal":
			if err := json.Unmarshal([]byte(v), &strct.Internal); err != nil {
				return err
			}
			internalReceived = true
		case "standard":
			if err := json.Unmarshal([]byte(v), &strct.Standard); err != nil {
				return err
			}
			standardReceived = true
		case "utility":
			if err := json.Unmarshal([]byte(v), &strct.Utility); err != nil {
				return err
			}
			utilityReceived = true
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	// check if hardpoints (a required property) was received
	if !hardpointsReceived {
		return errors.New("\"hardpoints\" is required but was not present")
	}
	// check if internal (a required property) was received
	if !internalReceived {
		return errors.New("\"internal\" is required but was not present")
	}
	// check if standard (a required property) was received
	if !standardReceived {
		return errors.New("\"standard\" is required but was not present")
	}
	// check if utility (a required property) was received
	if !utilityReceived {
		return errors.New("\"utility\" is required but was not present")
	}
	return nil
}

func (strct *FrameShiftDrive) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "blueprint" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"blueprint\": ")
	if tmp, err := json.Marshal(strct.Blueprint); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Class" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "class" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"class\": ")
	if tmp, err := json.Marshal(strct.Class); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Enabled" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "enabled" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "modifications" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"modifications\": ")
	if tmp, err := json.Marshal(strct.Modifications); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Priority" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "priority" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Rating" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "rating" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"rating\": ")
	if tmp, err := json.Marshal(strct.Rating); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FrameShiftDrive) UnmarshalJSON(b []byte) error {
	classReceived := false
	enabledReceived := false
	priorityReceived := false
	ratingReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "blueprint":
			if err := json.Unmarshal([]byte(v), &strct.Blueprint); err != nil {
				return err
			}
		case "class":
			if err := json.Unmarshal([]byte(v), &strct.Class); err != nil {
				return err
			}
			classReceived = true
		case "enabled":
			if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
				return err
			}
			enabledReceived = true
		case "modifications":
			if err := json.Unmarshal([]byte(v), &strct.Modifications); err != nil {
				return err
			}
		case "priority":
			if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
				return err
			}
			priorityReceived = true
		case "rating":
			if err := json.Unmarshal([]byte(v), &strct.Rating); err != nil {
				return err
			}
			ratingReceived = true
		}
	}
	// check if class (a required property) was received
	if !classReceived {
		return errors.New("\"class\" is required but was not present")
	}
	// check if enabled (a required property) was received
	if !enabledReceived {
		return errors.New("\"enabled\" is required but was not present")
	}
	// check if priority (a required property) was received
	if !priorityReceived {
		return errors.New("\"priority\" is required but was not present")
	}
	// check if rating (a required property) was received
	if !ratingReceived {
		return errors.New("\"rating\" is required but was not present")
	}
	return nil
}

func (strct *FuelTank) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "blueprint" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"blueprint\": ")
	if tmp, err := json.Marshal(strct.Blueprint); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Class" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "class" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"class\": ")
	if tmp, err := json.Marshal(strct.Class); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Enabled" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "enabled" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "modifications" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"modifications\": ")
	if tmp, err := json.Marshal(strct.Modifications); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Priority" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "priority" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Rating" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "rating" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"rating\": ")
	if tmp, err := json.Marshal(strct.Rating); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FuelTank) UnmarshalJSON(b []byte) error {
	classReceived := false
	enabledReceived := false
	priorityReceived := false
	ratingReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "blueprint":
			if err := json.Unmarshal([]byte(v), &strct.Blueprint); err != nil {
				return err
			}
		case "class":
			if err := json.Unmarshal([]byte(v), &strct.Class); err != nil {
				return err
			}
			classReceived = true
		case "enabled":
			if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
				return err
			}
			enabledReceived = true
		case "modifications":
			if err := json.Unmarshal([]byte(v), &strct.Modifications); err != nil {
				return err
			}
		case "priority":
			if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
				return err
			}
			priorityReceived = true
		case "rating":
			if err := json.Unmarshal([]byte(v), &strct.Rating); err != nil {
				return err
			}
			ratingReceived = true
		}
	}
	// check if class (a required property) was received
	if !classReceived {
		return errors.New("\"class\" is required but was not present")
	}
	// check if enabled (a required property) was received
	if !enabledReceived {
		return errors.New("\"enabled\" is required but was not present")
	}
	// check if priority (a required property) was received
	if !priorityReceived {
		return errors.New("\"priority\" is required but was not present")
	}
	// check if rating (a required property) was received
	if !ratingReceived {
		return errors.New("\"rating\" is required but was not present")
	}
	return nil
}

func (strct *HardpointsItems_object) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "blueprint" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"blueprint\": ")
	if tmp, err := json.Marshal(strct.Blueprint); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Class" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "class" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"class\": ")
	if tmp, err := json.Marshal(strct.Class); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Enabled" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "enabled" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Group" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "group" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"group\": ")
	if tmp, err := json.Marshal(strct.Group); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "modifications" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"modifications\": ")
	if tmp, err := json.Marshal(strct.Modifications); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Mount" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "mount" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"mount\": ")
	if tmp, err := json.Marshal(strct.Mount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Priority" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "priority" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Rating" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "rating" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"rating\": ")
	if tmp, err := json.Marshal(strct.Rating); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HardpointsItems_object) UnmarshalJSON(b []byte) error {
	classReceived := false
	enabledReceived := false
	groupReceived := false
	mountReceived := false
	priorityReceived := false
	ratingReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "blueprint":
			if err := json.Unmarshal([]byte(v), &strct.Blueprint); err != nil {
				return err
			}
		case "class":
			if err := json.Unmarshal([]byte(v), &strct.Class); err != nil {
				return err
			}
			classReceived = true
		case "enabled":
			if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
				return err
			}
			enabledReceived = true
		case "group":
			if err := json.Unmarshal([]byte(v), &strct.Group); err != nil {
				return err
			}
			groupReceived = true
		case "modifications":
			if err := json.Unmarshal([]byte(v), &strct.Modifications); err != nil {
				return err
			}
		case "mount":
			if err := json.Unmarshal([]byte(v), &strct.Mount); err != nil {
				return err
			}
			mountReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "priority":
			if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
				return err
			}
			priorityReceived = true
		case "rating":
			if err := json.Unmarshal([]byte(v), &strct.Rating); err != nil {
				return err
			}
			ratingReceived = true
		}
	}
	// check if class (a required property) was received
	if !classReceived {
		return errors.New("\"class\" is required but was not present")
	}
	// check if enabled (a required property) was received
	if !enabledReceived {
		return errors.New("\"enabled\" is required but was not present")
	}
	// check if group (a required property) was received
	if !groupReceived {
		return errors.New("\"group\" is required but was not present")
	}
	// check if mount (a required property) was received
	if !mountReceived {
		return errors.New("\"mount\" is required but was not present")
	}
	// check if priority (a required property) was received
	if !priorityReceived {
		return errors.New("\"priority\" is required but was not present")
	}
	// check if rating (a required property) was received
	if !ratingReceived {
		return errors.New("\"rating\" is required but was not present")
	}
	return nil
}

func (strct *InternalItems_object) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "blueprint" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"blueprint\": ")
	if tmp, err := json.Marshal(strct.Blueprint); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Class" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "class" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"class\": ")
	if tmp, err := json.Marshal(strct.Class); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Enabled" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "enabled" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Group" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "group" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"group\": ")
	if tmp, err := json.Marshal(strct.Group); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "modifications" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"modifications\": ")
	if tmp, err := json.Marshal(strct.Modifications); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Priority" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "priority" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Rating" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "rating" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"rating\": ")
	if tmp, err := json.Marshal(strct.Rating); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InternalItems_object) UnmarshalJSON(b []byte) error {
	classReceived := false
	enabledReceived := false
	groupReceived := false
	priorityReceived := false
	ratingReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "blueprint":
			if err := json.Unmarshal([]byte(v), &strct.Blueprint); err != nil {
				return err
			}
		case "class":
			if err := json.Unmarshal([]byte(v), &strct.Class); err != nil {
				return err
			}
			classReceived = true
		case "enabled":
			if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
				return err
			}
			enabledReceived = true
		case "group":
			if err := json.Unmarshal([]byte(v), &strct.Group); err != nil {
				return err
			}
			groupReceived = true
		case "modifications":
			if err := json.Unmarshal([]byte(v), &strct.Modifications); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "priority":
			if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
				return err
			}
			priorityReceived = true
		case "rating":
			if err := json.Unmarshal([]byte(v), &strct.Rating); err != nil {
				return err
			}
			ratingReceived = true
		}
	}
	// check if class (a required property) was received
	if !classReceived {
		return errors.New("\"class\" is required but was not present")
	}
	// check if enabled (a required property) was received
	if !enabledReceived {
		return errors.New("\"enabled\" is required but was not present")
	}
	// check if group (a required property) was received
	if !groupReceived {
		return errors.New("\"group\" is required but was not present")
	}
	// check if priority (a required property) was received
	if !priorityReceived {
		return errors.New("\"priority\" is required but was not present")
	}
	// check if rating (a required property) was received
	if !ratingReceived {
		return errors.New("\"rating\" is required but was not present")
	}
	return nil
}

func (strct *LifeSupport) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "blueprint" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"blueprint\": ")
	if tmp, err := json.Marshal(strct.Blueprint); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Class" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "class" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"class\": ")
	if tmp, err := json.Marshal(strct.Class); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Enabled" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "enabled" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "modifications" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"modifications\": ")
	if tmp, err := json.Marshal(strct.Modifications); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Priority" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "priority" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Rating" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "rating" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"rating\": ")
	if tmp, err := json.Marshal(strct.Rating); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LifeSupport) UnmarshalJSON(b []byte) error {
	classReceived := false
	enabledReceived := false
	priorityReceived := false
	ratingReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "blueprint":
			if err := json.Unmarshal([]byte(v), &strct.Blueprint); err != nil {
				return err
			}
		case "class":
			if err := json.Unmarshal([]byte(v), &strct.Class); err != nil {
				return err
			}
			classReceived = true
		case "enabled":
			if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
				return err
			}
			enabledReceived = true
		case "modifications":
			if err := json.Unmarshal([]byte(v), &strct.Modifications); err != nil {
				return err
			}
		case "priority":
			if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
				return err
			}
			priorityReceived = true
		case "rating":
			if err := json.Unmarshal([]byte(v), &strct.Rating); err != nil {
				return err
			}
			ratingReceived = true
		}
	}
	// check if class (a required property) was received
	if !classReceived {
		return errors.New("\"class\" is required but was not present")
	}
	// check if enabled (a required property) was received
	if !enabledReceived {
		return errors.New("\"enabled\" is required but was not present")
	}
	// check if priority (a required property) was received
	if !priorityReceived {
		return errors.New("\"priority\" is required but was not present")
	}
	// check if rating (a required property) was received
	if !ratingReceived {
		return errors.New("\"rating\" is required but was not present")
	}
	return nil
}

func (strct *PowerDistributor) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "blueprint" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"blueprint\": ")
	if tmp, err := json.Marshal(strct.Blueprint); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Class" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "class" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"class\": ")
	if tmp, err := json.Marshal(strct.Class); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Enabled" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "enabled" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "modifications" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"modifications\": ")
	if tmp, err := json.Marshal(strct.Modifications); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Priority" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "priority" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Rating" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "rating" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"rating\": ")
	if tmp, err := json.Marshal(strct.Rating); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PowerDistributor) UnmarshalJSON(b []byte) error {
	classReceived := false
	enabledReceived := false
	priorityReceived := false
	ratingReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "blueprint":
			if err := json.Unmarshal([]byte(v), &strct.Blueprint); err != nil {
				return err
			}
		case "class":
			if err := json.Unmarshal([]byte(v), &strct.Class); err != nil {
				return err
			}
			classReceived = true
		case "enabled":
			if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
				return err
			}
			enabledReceived = true
		case "modifications":
			if err := json.Unmarshal([]byte(v), &strct.Modifications); err != nil {
				return err
			}
		case "priority":
			if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
				return err
			}
			priorityReceived = true
		case "rating":
			if err := json.Unmarshal([]byte(v), &strct.Rating); err != nil {
				return err
			}
			ratingReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		}
	}
	// check if class (a required property) was received
	if !classReceived {
		return errors.New("\"class\" is required but was not present")
	}
	// check if enabled (a required property) was received
	if !enabledReceived {
		return errors.New("\"enabled\" is required but was not present")
	}
	// check if priority (a required property) was received
	if !priorityReceived {
		return errors.New("\"priority\" is required but was not present")
	}
	// check if rating (a required property) was received
	if !ratingReceived {
		return errors.New("\"rating\" is required but was not present")
	}
	return nil
}

func (strct *PowerPlant) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "blueprint" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"blueprint\": ")
	if tmp, err := json.Marshal(strct.Blueprint); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Class" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "class" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"class\": ")
	if tmp, err := json.Marshal(strct.Class); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Enabled" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "enabled" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "modifications" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"modifications\": ")
	if tmp, err := json.Marshal(strct.Modifications); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Priority" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "priority" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Rating" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "rating" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"rating\": ")
	if tmp, err := json.Marshal(strct.Rating); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PowerPlant) UnmarshalJSON(b []byte) error {
	classReceived := false
	enabledReceived := false
	priorityReceived := false
	ratingReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "blueprint":
			if err := json.Unmarshal([]byte(v), &strct.Blueprint); err != nil {
				return err
			}
		case "class":
			if err := json.Unmarshal([]byte(v), &strct.Class); err != nil {
				return err
			}
			classReceived = true
		case "enabled":
			if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
				return err
			}
			enabledReceived = true
		case "modifications":
			if err := json.Unmarshal([]byte(v), &strct.Modifications); err != nil {
				return err
			}
		case "priority":
			if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
				return err
			}
			priorityReceived = true
		case "rating":
			if err := json.Unmarshal([]byte(v), &strct.Rating); err != nil {
				return err
			}
			ratingReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		}
	}
	// check if class (a required property) was received
	if !classReceived {
		return errors.New("\"class\" is required but was not present")
	}
	// check if enabled (a required property) was received
	if !enabledReceived {
		return errors.New("\"enabled\" is required but was not present")
	}
	// check if priority (a required property) was received
	if !priorityReceived {
		return errors.New("\"priority\" is required but was not present")
	}
	// check if rating (a required property) was received
	if !ratingReceived {
		return errors.New("\"rating\" is required but was not present")
	}
	return nil
}

func (strct *ReferencesItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReferencesItems) UnmarshalJSON(b []byte) error {
	nameReceived := false
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *Sensors) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "blueprint" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"blueprint\": ")
	if tmp, err := json.Marshal(strct.Blueprint); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Class" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "class" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"class\": ")
	if tmp, err := json.Marshal(strct.Class); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Enabled" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "enabled" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "modifications" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"modifications\": ")
	if tmp, err := json.Marshal(strct.Modifications); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Priority" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "priority" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Rating" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "rating" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"rating\": ")
	if tmp, err := json.Marshal(strct.Rating); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Sensors) UnmarshalJSON(b []byte) error {
	classReceived := false
	enabledReceived := false
	priorityReceived := false
	ratingReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "blueprint":
			if err := json.Unmarshal([]byte(v), &strct.Blueprint); err != nil {
				return err
			}
		case "class":
			if err := json.Unmarshal([]byte(v), &strct.Class); err != nil {
				return err
			}
			classReceived = true
		case "enabled":
			if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
				return err
			}
			enabledReceived = true
		case "modifications":
			if err := json.Unmarshal([]byte(v), &strct.Modifications); err != nil {
				return err
			}
		case "priority":
			if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
				return err
			}
			priorityReceived = true
		case "rating":
			if err := json.Unmarshal([]byte(v), &strct.Rating); err != nil {
				return err
			}
			ratingReceived = true
		}
	}
	// check if class (a required property) was received
	if !classReceived {
		return errors.New("\"class\" is required but was not present")
	}
	// check if enabled (a required property) was received
	if !enabledReceived {
		return errors.New("\"enabled\" is required but was not present")
	}
	// check if priority (a required property) was received
	if !priorityReceived {
		return errors.New("\"priority\" is required but was not present")
	}
	// check if rating (a required property) was received
	if !ratingReceived {
		return errors.New("\"rating\" is required but was not present")
	}
	return nil
}

func (strct *ShipLoadout) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Components" field is required
	if strct.Components == nil {
		return nil, errors.New("components is a required field")
	}
	// Marshal the "components" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"components\": ")
	if tmp, err := json.Marshal(strct.Components); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "manufacturer" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"manufacturer\": ")
	if tmp, err := json.Marshal(strct.Manufacturer); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "references" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"references\": ")
	if tmp, err := json.Marshal(strct.References); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Ship" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "ship" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"ship\": ")
	if tmp, err := json.Marshal(strct.Ship); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "stats" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"stats\": ")
	if tmp, err := json.Marshal(strct.Stats); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ShipLoadout) UnmarshalJSON(b []byte) error {
	componentsReceived := false
	nameReceived := false
	shipReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "components":
			if err := json.Unmarshal([]byte(v), &strct.Components); err != nil {
				return err
			}
			componentsReceived = true
		case "manufacturer":
			if err := json.Unmarshal([]byte(v), &strct.Manufacturer); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		case "references":
			if err := json.Unmarshal([]byte(v), &strct.References); err != nil {
				return err
			}
		case "ship":
			if err := json.Unmarshal([]byte(v), &strct.Ship); err != nil {
				return err
			}
			shipReceived = true
		case "stats":
			if err := json.Unmarshal([]byte(v), &strct.Stats); err != nil {
				return err
			}
		}
	}
	// check if components (a required property) was received
	if !componentsReceived {
		return errors.New("\"components\" is required but was not present")
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	// check if ship (a required property) was received
	if !shipReceived {
		return errors.New("\"ship\" is required but was not present")
	}
	return nil
}

func (strct *Standard) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Bulkheads" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "bulkheads" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"bulkheads\": ")
	if tmp, err := json.Marshal(strct.Bulkheads); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "CargoHatch" field is required
	if strct.CargoHatch == nil {
		return nil, errors.New("cargoHatch is a required field")
	}
	// Marshal the "cargoHatch" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"cargoHatch\": ")
	if tmp, err := json.Marshal(strct.CargoHatch); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "FrameShiftDrive" field is required
	if strct.FrameShiftDrive == nil {
		return nil, errors.New("frameShiftDrive is a required field")
	}
	// Marshal the "frameShiftDrive" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"frameShiftDrive\": ")
	if tmp, err := json.Marshal(strct.FrameShiftDrive); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "FuelTank" field is required
	if strct.FuelTank == nil {
		return nil, errors.New("fuelTank is a required field")
	}
	// Marshal the "fuelTank" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"fuelTank\": ")
	if tmp, err := json.Marshal(strct.FuelTank); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "LifeSupport" field is required
	if strct.LifeSupport == nil {
		return nil, errors.New("lifeSupport is a required field")
	}
	// Marshal the "lifeSupport" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"lifeSupport\": ")
	if tmp, err := json.Marshal(strct.LifeSupport); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "PowerDistributor" field is required
	if strct.PowerDistributor == nil {
		return nil, errors.New("powerDistributor is a required field")
	}
	// Marshal the "powerDistributor" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"powerDistributor\": ")
	if tmp, err := json.Marshal(strct.PowerDistributor); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "PowerPlant" field is required
	if strct.PowerPlant == nil {
		return nil, errors.New("powerPlant is a required field")
	}
	// Marshal the "powerPlant" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"powerPlant\": ")
	if tmp, err := json.Marshal(strct.PowerPlant); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Sensors" field is required
	if strct.Sensors == nil {
		return nil, errors.New("sensors is a required field")
	}
	// Marshal the "sensors" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"sensors\": ")
	if tmp, err := json.Marshal(strct.Sensors); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Thrusters" field is required
	if strct.Thrusters == nil {
		return nil, errors.New("thrusters is a required field")
	}
	// Marshal the "thrusters" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"thrusters\": ")
	if tmp, err := json.Marshal(strct.Thrusters); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Standard) UnmarshalJSON(b []byte) error {
	bulkheadsReceived := false
	cargoHatchReceived := false
	frameShiftDriveReceived := false
	fuelTankReceived := false
	lifeSupportReceived := false
	powerDistributorReceived := false
	powerPlantReceived := false
	sensorsReceived := false
	thrustersReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "bulkheads":
			if err := json.Unmarshal([]byte(v), &strct.Bulkheads); err != nil {
				return err
			}
			bulkheadsReceived = true
		case "cargoHatch":
			if err := json.Unmarshal([]byte(v), &strct.CargoHatch); err != nil {
				return err
			}
			cargoHatchReceived = true
		case "frameShiftDrive":
			if err := json.Unmarshal([]byte(v), &strct.FrameShiftDrive); err != nil {
				return err
			}
			frameShiftDriveReceived = true
		case "fuelTank":
			if err := json.Unmarshal([]byte(v), &strct.FuelTank); err != nil {
				return err
			}
			fuelTankReceived = true
		case "lifeSupport":
			if err := json.Unmarshal([]byte(v), &strct.LifeSupport); err != nil {
				return err
			}
			lifeSupportReceived = true
		case "powerDistributor":
			if err := json.Unmarshal([]byte(v), &strct.PowerDistributor); err != nil {
				return err
			}
			powerDistributorReceived = true
		case "powerPlant":
			if err := json.Unmarshal([]byte(v), &strct.PowerPlant); err != nil {
				return err
			}
			powerPlantReceived = true
		case "sensors":
			if err := json.Unmarshal([]byte(v), &strct.Sensors); err != nil {
				return err
			}
			sensorsReceived = true
		case "thrusters":
			if err := json.Unmarshal([]byte(v), &strct.Thrusters); err != nil {
				return err
			}
			thrustersReceived = true
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	// check if bulkheads (a required property) was received
	if !bulkheadsReceived {
		return errors.New("\"bulkheads\" is required but was not present")
	}
	// check if cargoHatch (a required property) was received
	if !cargoHatchReceived {
		return errors.New("\"cargoHatch\" is required but was not present")
	}
	// check if frameShiftDrive (a required property) was received
	if !frameShiftDriveReceived {
		return errors.New("\"frameShiftDrive\" is required but was not present")
	}
	// check if fuelTank (a required property) was received
	if !fuelTankReceived {
		return errors.New("\"fuelTank\" is required but was not present")
	}
	// check if lifeSupport (a required property) was received
	if !lifeSupportReceived {
		return errors.New("\"lifeSupport\" is required but was not present")
	}
	// check if powerDistributor (a required property) was received
	if !powerDistributorReceived {
		return errors.New("\"powerDistributor\" is required but was not present")
	}
	// check if powerPlant (a required property) was received
	if !powerPlantReceived {
		return errors.New("\"powerPlant\" is required but was not present")
	}
	// check if sensors (a required property) was received
	if !sensorsReceived {
		return errors.New("\"sensors\" is required but was not present")
	}
	// check if thrusters (a required property) was received
	if !thrustersReceived {
		return errors.New("\"thrusters\" is required but was not present")
	}
	return nil
}

func (strct *Stats) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "agility" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"agility\": ")
	if tmp, err := json.Marshal(strct.Agility); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "armour" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"armour\": ")
	if tmp, err := json.Marshal(strct.Armour); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "armourAdded" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"armourAdded\": ")
	if tmp, err := json.Marshal(strct.ArmourAdded); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "baseArmour" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"baseArmour\": ")
	if tmp, err := json.Marshal(strct.BaseArmour); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "baseShieldStrength" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"baseShieldStrength\": ")
	if tmp, err := json.Marshal(strct.BaseShieldStrength); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "boost" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"boost\": ")
	if tmp, err := json.Marshal(strct.Boost); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "cargoCapacity" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"cargoCapacity\": ")
	if tmp, err := json.Marshal(strct.CargoCapacity); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "class" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"class\": ")
	if tmp, err := json.Marshal(strct.Class); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "fuelCapacity" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"fuelCapacity\": ")
	if tmp, err := json.Marshal(strct.FuelCapacity); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "fullTankRange" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"fullTankRange\": ")
	if tmp, err := json.Marshal(strct.FullTankRange); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "hullCost" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"hullCost\": ")
	if tmp, err := json.Marshal(strct.HullCost); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "hullExplRes" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"hullExplRes\": ")
	if tmp, err := json.Marshal(strct.HullExplRes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "hullKinRes" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"hullKinRes\": ")
	if tmp, err := json.Marshal(strct.HullKinRes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "hullMass" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"hullMass\": ")
	if tmp, err := json.Marshal(strct.HullMass); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "hullThermRes" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"hullThermRes\": ")
	if tmp, err := json.Marshal(strct.HullThermRes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "ladenMass" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"ladenMass\": ")
	if tmp, err := json.Marshal(strct.LadenMass); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "ladenRange" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"ladenRange\": ")
	if tmp, err := json.Marshal(strct.LadenRange); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "masslock" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"masslock\": ")
	if tmp, err := json.Marshal(strct.Masslock); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "shield" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"shield\": ")
	if tmp, err := json.Marshal(strct.Shield); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "shieldExplRes" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"shieldExplRes\": ")
	if tmp, err := json.Marshal(strct.ShieldExplRes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "shieldKinRes" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"shieldKinRes\": ")
	if tmp, err := json.Marshal(strct.ShieldKinRes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "shieldThermRes" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"shieldThermRes\": ")
	if tmp, err := json.Marshal(strct.ShieldThermRes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "speed" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"speed\": ")
	if tmp, err := json.Marshal(strct.Speed); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "totalCost" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"totalCost\": ")
	if tmp, err := json.Marshal(strct.TotalCost); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "totalDps" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"totalDps\": ")
	if tmp, err := json.Marshal(strct.TotalDps); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "totalEps" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"totalEps\": ")
	if tmp, err := json.Marshal(strct.TotalEps); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "totalHps" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"totalHps\": ")
	if tmp, err := json.Marshal(strct.TotalHps); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "unladenMass" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unladenMass\": ")
	if tmp, err := json.Marshal(strct.UnladenMass); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "unladenRange" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unladenRange\": ")
	if tmp, err := json.Marshal(strct.UnladenRange); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Stats) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "agility":
			if err := json.Unmarshal([]byte(v), &strct.Agility); err != nil {
				return err
			}
		case "armour":
			if err := json.Unmarshal([]byte(v), &strct.Armour); err != nil {
				return err
			}
		case "armourAdded":
			if err := json.Unmarshal([]byte(v), &strct.ArmourAdded); err != nil {
				return err
			}
		case "baseArmour":
			if err := json.Unmarshal([]byte(v), &strct.BaseArmour); err != nil {
				return err
			}
		case "baseShieldStrength":
			if err := json.Unmarshal([]byte(v), &strct.BaseShieldStrength); err != nil {
				return err
			}
		case "boost":
			if err := json.Unmarshal([]byte(v), &strct.Boost); err != nil {
				return err
			}
		case "cargoCapacity":
			if err := json.Unmarshal([]byte(v), &strct.CargoCapacity); err != nil {
				return err
			}
		case "class":
			if err := json.Unmarshal([]byte(v), &strct.Class); err != nil {
				return err
			}
		case "fuelCapacity":
			if err := json.Unmarshal([]byte(v), &strct.FuelCapacity); err != nil {
				return err
			}
		case "fullTankRange":
			if err := json.Unmarshal([]byte(v), &strct.FullTankRange); err != nil {
				return err
			}
		case "hullCost":
			if err := json.Unmarshal([]byte(v), &strct.HullCost); err != nil {
				return err
			}
		case "hullExplRes":
			if err := json.Unmarshal([]byte(v), &strct.HullExplRes); err != nil {
				return err
			}
		case "hullKinRes":
			if err := json.Unmarshal([]byte(v), &strct.HullKinRes); err != nil {
				return err
			}
		case "hullMass":
			if err := json.Unmarshal([]byte(v), &strct.HullMass); err != nil {
				return err
			}
		case "hullThermRes":
			if err := json.Unmarshal([]byte(v), &strct.HullThermRes); err != nil {
				return err
			}
		case "ladenMass":
			if err := json.Unmarshal([]byte(v), &strct.LadenMass); err != nil {
				return err
			}
		case "ladenRange":
			if err := json.Unmarshal([]byte(v), &strct.LadenRange); err != nil {
				return err
			}
		case "masslock":
			if err := json.Unmarshal([]byte(v), &strct.Masslock); err != nil {
				return err
			}
		case "shield":
			if err := json.Unmarshal([]byte(v), &strct.Shield); err != nil {
				return err
			}
		case "shieldExplRes":
			if err := json.Unmarshal([]byte(v), &strct.ShieldExplRes); err != nil {
				return err
			}
		case "shieldKinRes":
			if err := json.Unmarshal([]byte(v), &strct.ShieldKinRes); err != nil {
				return err
			}
		case "shieldThermRes":
			if err := json.Unmarshal([]byte(v), &strct.ShieldThermRes); err != nil {
				return err
			}
		case "speed":
			if err := json.Unmarshal([]byte(v), &strct.Speed); err != nil {
				return err
			}
		case "totalCost":
			if err := json.Unmarshal([]byte(v), &strct.TotalCost); err != nil {
				return err
			}
		case "totalDps":
			if err := json.Unmarshal([]byte(v), &strct.TotalDps); err != nil {
				return err
			}
		case "totalEps":
			if err := json.Unmarshal([]byte(v), &strct.TotalEps); err != nil {
				return err
			}
		case "totalHps":
			if err := json.Unmarshal([]byte(v), &strct.TotalHps); err != nil {
				return err
			}
		case "unladenMass":
			if err := json.Unmarshal([]byte(v), &strct.UnladenMass); err != nil {
				return err
			}
		case "unladenRange":
			if err := json.Unmarshal([]byte(v), &strct.UnladenRange); err != nil {
				return err
			}
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *Thrusters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "blueprint" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"blueprint\": ")
	if tmp, err := json.Marshal(strct.Blueprint); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Class" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "class" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"class\": ")
	if tmp, err := json.Marshal(strct.Class); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Enabled" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "enabled" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "modifications" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"modifications\": ")
	if tmp, err := json.Marshal(strct.Modifications); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Priority" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "priority" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Rating" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "rating" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"rating\": ")
	if tmp, err := json.Marshal(strct.Rating); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Thrusters) UnmarshalJSON(b []byte) error {
	classReceived := false
	enabledReceived := false
	priorityReceived := false
	ratingReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "blueprint":
			if err := json.Unmarshal([]byte(v), &strct.Blueprint); err != nil {
				return err
			}
		case "class":
			if err := json.Unmarshal([]byte(v), &strct.Class); err != nil {
				return err
			}
			classReceived = true
		case "enabled":
			if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
				return err
			}
			enabledReceived = true
		case "modifications":
			if err := json.Unmarshal([]byte(v), &strct.Modifications); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "priority":
			if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
				return err
			}
			priorityReceived = true
		case "rating":
			if err := json.Unmarshal([]byte(v), &strct.Rating); err != nil {
				return err
			}
			ratingReceived = true
		}
	}
	// check if class (a required property) was received
	if !classReceived {
		return errors.New("\"class\" is required but was not present")
	}
	// check if enabled (a required property) was received
	if !enabledReceived {
		return errors.New("\"enabled\" is required but was not present")
	}
	// check if priority (a required property) was received
	if !priorityReceived {
		return errors.New("\"priority\" is required but was not present")
	}
	// check if rating (a required property) was received
	if !ratingReceived {
		return errors.New("\"rating\" is required but was not present")
	}
	return nil
}

func (strct *UtilityItems_object) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "blueprint" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"blueprint\": ")
	if tmp, err := json.Marshal(strct.Blueprint); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Class" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "class" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"class\": ")
	if tmp, err := json.Marshal(strct.Class); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Enabled" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "enabled" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"enabled\": ")
	if tmp, err := json.Marshal(strct.Enabled); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Group" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "group" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"group\": ")
	if tmp, err := json.Marshal(strct.Group); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "modifications" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"modifications\": ")
	if tmp, err := json.Marshal(strct.Modifications); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Priority" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "priority" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"priority\": ")
	if tmp, err := json.Marshal(strct.Priority); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Rating" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "rating" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"rating\": ")
	if tmp, err := json.Marshal(strct.Rating); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *UtilityItems_object) UnmarshalJSON(b []byte) error {
	classReceived := false
	enabledReceived := false
	groupReceived := false
	priorityReceived := false
	ratingReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "blueprint":
			if err := json.Unmarshal([]byte(v), &strct.Blueprint); err != nil {
				return err
			}
		case "class":
			if err := json.Unmarshal([]byte(v), &strct.Class); err != nil {
				return err
			}
			classReceived = true
		case "enabled":
			if err := json.Unmarshal([]byte(v), &strct.Enabled); err != nil {
				return err
			}
			enabledReceived = true
		case "group":
			if err := json.Unmarshal([]byte(v), &strct.Group); err != nil {
				return err
			}
			groupReceived = true
		case "modifications":
			if err := json.Unmarshal([]byte(v), &strct.Modifications); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "priority":
			if err := json.Unmarshal([]byte(v), &strct.Priority); err != nil {
				return err
			}
			priorityReceived = true
		case "rating":
			if err := json.Unmarshal([]byte(v), &strct.Rating); err != nil {
				return err
			}
			ratingReceived = true
		}
	}
	// check if class (a required property) was received
	if !classReceived {
		return errors.New("\"class\" is required but was not present")
	}
	// check if enabled (a required property) was received
	if !enabledReceived {
		return errors.New("\"enabled\" is required but was not present")
	}
	// check if group (a required property) was received
	if !groupReceived {
		return errors.New("\"group\" is required but was not present")
	}
	// check if priority (a required property) was received
	if !priorityReceived {
		return errors.New("\"priority\" is required but was not present")
	}
	// check if rating (a required property) was received
	if !ratingReceived {
		return errors.New("\"rating\" is required but was not present")
	}
	return nil
}

func (strct Thrusters) String() string {
	nam := strct.Name
	if nam == "" {
		nam = "Thruster"
	}
	return fmt.Sprintf("%d%s %s", strct.Class, strct.Rating, nam)
}

func (strct PowerPlant) String() string {
	nam := strct.Name
	if nam == "" {
		nam = "Power Plant"
	}
	return fmt.Sprintf("%d%s %s", strct.Class, strct.Rating, nam)
}

func (strct PowerDistributor) String() string {
	nam := strct.Name
	if nam == "" {
		nam = "Power Distributor"
	}
	return fmt.Sprintf("%d%s %s", strct.Class, strct.Rating, nam)
}

func (strct FrameShiftDrive) String() string {
	return fmt.Sprintf("%d%s Frame Shift Drive", strct.Class, strct.Rating)
}

func (strct LifeSupport) String() string {
	return fmt.Sprintf("%d%s Life Support", strct.Class, strct.Rating)
}

func (strct Sensors) String() string {
	return fmt.Sprintf("%d%s Sensors", strct.Class, strct.Rating)
}
func (strct FuelTank) String() string {
	return fmt.Sprintf("%d%s Fuel Tank", strct.Class, strct.Rating)
}

func (strct UtilityItems_object) String() string {
	return fmt.Sprintf("%d%s %s", strct.Class, strct.Rating, strct.Name)
}
